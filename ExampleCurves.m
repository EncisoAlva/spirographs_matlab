% Small collection of curves that I have used to make animations. Feel free
% to use them for exploring.


CtrlPtsArray = {[...
  [-3,0]',...
  [-3,0]'+3*[0,(4/3)*tan(pi/8)]',...
  [0,3]'+3*[-(4/3)*tan(pi/8),0]',...
  [0,3]'...
  ],[...
  [0,3]',...
  [0,3]'+[(4/3)*tan(pi/4),0]',...
  [0,1]'+[(4/3)*tan(pi/4),0]',...
  [0,1]'...
  ],[...
  [0,1]',...
  [0,1]'+[-(4/3)*tan(pi/4),0]',...
  [0,-1]'+[-(4/3)*tan(pi/4),0]',...
  [0,-1]'...
  ],[...
  [0,-1]',...
  [0,-1]'+[(4/3)*tan(pi/4),0]',...
  [0,-3]'+[(4/3)*tan(pi/4),0]',...
  [0,-3]'...
  ],[...
  [0,-3]',...
  [0,-3]'+3*[-(4/3)*tan(pi/8),0]',...
  [-3,0]'+3*[0,-(4/3)*tan(pi/8)]',...
  [-3,0]'...
  ]};

% semicircles S
CtrlPtsArray = {[...
  [0,-1]',...
  [-(8/3)*tan(pi/4)',-1]',...
  [-(8/3)*tan(pi/4)',1]',...
  [0,1]'...
  ],[...
  [0,1]',...
  [-(4/3)*tan(pi/4)',1]',...
  [-(4/3)*tan(pi/4)',0]',...
  [0,0]'...
  ],[...
  [0,0]',...
  [(8/3)*tan(pi/4)',0]',...
  [(8/3)*tan(pi/4)',-2]',...
  [0,-2]'...
  ],[...
  [0,-2]'...
  [(4/3)*tan(pi/4)',-2]',...
  [(4/3)*tan(pi/4)',-1]',...
  [0,-1]'...
  ]};

% heart
CtrlPtsArray = {[...
  [-2,0]',...
  [-2,(4/3)*tan(pi/4)]',...
  [0,(4/3)*tan(pi/4)]',...
  [0,0]'...
  ],[...
  [0,0]',...
  [0,(4/3)*tan(pi/4)]',...
  [2,(4/3)*tan(pi/4)]',...
  [2,0]',...
  ],[...
  [2,0]',...
  [2,-2*(4/3)*tan(pi/16)]',...
  [2/sqrt(2),-2/sqrt(2)]'+2*[1/sqrt(2),1/sqrt(2)]'*(4/3)*tan(pi/16),...
  [2/sqrt(2),-2/sqrt(2)]'...
  ],[...
  [2/sqrt(2),-2/sqrt(2)]',...
  [2/sqrt(2),-2/sqrt(2)]'+[-.5,-.5]',...
  [0,-4/sqrt(2)]'+[.5,.5]',...
  [0,-4/sqrt(2)]'...
  ],[...
  [0,-4/sqrt(2)]',...
  [0,-4/sqrt(2)]'+[-.5,.5]',...
  [-2/sqrt(2),-2/sqrt(2)]'+[.5,-.5]',...
  [-2/sqrt(2),-2/sqrt(2)]',...
  ],[...
  [-2/sqrt(2),-2/sqrt(2)]'...
  [-2/sqrt(2),-2/sqrt(2)]'+2*[-1/sqrt(2),1/sqrt(2)]'*(4/3)*tan(pi/16),...
  [-2,-2*(4/3)*tan(pi/16)]',...
  [-2,0]'...
  ]};

% simple 4-spike star
[c1, c2] = HalfBezierSingle([...
  [-1,0]',...
  [-1,0]'+[1, 0]'*(4/3)*tan(pi/8), ...
  [ 0,1]'+[0,-1]'*(4/3)*tan(pi/8), ...
  [0,1]'
  ]);
CtrlPtsArray = {c2,[...
  [0,1]',...
  [0,1]'+[0,-1]'*(4/3)*tan(pi/8), ...
  [1,0]'+[-1,0]'*(4/3)*tan(pi/8), ...
  [1,0]'
  ],[...
  [1,0]',...
  [1,0]'+[-1,0]'*(4/3)*tan(pi/8), ...
  [0,-1]'+[0,1]'*(4/3)*tan(pi/8), ...
  [0,-1]'
  ],[...
  [0,-1]',...
  [0,-1]'+[0,1]'*(4/3)*tan(pi/8), ...
  [-1,0]'+[1,0]'*(4/3)*tan(pi/8), ...
  [-1,0]'
  ], c1};

% rotated square
CtrlPtsArray = {...
  LineToBezier([-1,1]',[0,2]'), ...
  LineToBezier([0,2]',[2,0]'), ...
  LineToBezier([2,0]',[0,-2]'), ...
  LineToBezier([0,-2]',[-2,0]'), ...
  LineToBezier([-2,0]',[-1,1]') ...
  };

% number 8 from two circles
CtrlPtsArray = {[...
  [0,-1]',...
  [0,-1]'+[-1,0]'*(4/3)*tan(pi/8),...
  [-1,0]'+[0,-1]'*(4/3)*tan(pi/8),...
  [-1,0]'
  ],[...
  [-1,0]',...
  [-1,0]'+[0,1]'*(4/3)*tan(pi/8),...
  [0,1]'+[-1,0]'*(4/3)*tan(pi/8),...
  [0,1]'...
  ],...
  [...
  [0,1]',...
  [0,1]'+[-1,0]'*(4/3)*tan(pi/8),...
  [-1,2]'+[0,-1]'*(4/3)*tan(pi/8),...
  [-1,2]'
  ],[...
  [-1,2]',...
  [-1,2]'+[0,1]'*(4/3)*tan(pi/8),...
  [0,3]'+[-1,0]'*(4/3)*tan(pi/8),...
  [0,3]'...
  ],...
  [...
  [0,3]',...
  [0,3]'+[1,0]'*(4/3)*tan(pi/8),...
  [1,2]'+[0,1]'*(4/3)*tan(pi/8),...
  [1,2]'...
  ],[...
  [1,2]',...
  [1,2]'+[0,-1]'*(4/3)*tan(pi/8),...
  [0,1]'+[1,0]'*(4/3)*tan(pi/8),...
  [0,1]'
  ],...
  [...
  [0,1]',...
  [0,1]'+[1,0]'*(4/3)*tan(pi/8),...
  [1,0]'+[0,1]'*(4/3)*tan(pi/8),...
  [1,0]'...
  ],[...
  [1,0]',...
  [1,0]'+[0,-1]'*(4/3)*tan(pi/8),...
  [0,-1]'+[1,0]'*(4/3)*tan(pi/8),...
  [0,-1]'
  ]};

% bold letter B
CtrlPtsArray = {...
  LineToBezier([-1,1]',[-1,3]'),...
  LineToBezier([-1,3]',[0,3]'),...
  [...
  [0,3]',...
  [0,3]'+[1,0]'*(4/3)*tan(pi/8),...
  [1,2]'+[0,1]'*(4/3)*tan(pi/8),...
  [1,2]'...
  ],[...
  [1,2]',...
  [1,2]'+[0,-1]'*(4/3)*tan(pi/8),...
  [0,1]'+[1,0]'*(4/3)*tan(pi/8),...
  [0,1]'
  ],[...
  [0,1]',...
  [0,1]'+[1,0]'*(4/3)*tan(pi/8),...
  [1,0]'+[0,1]'*(4/3)*tan(pi/8),...
  [1,0]'...
  ],[...
  [1,0]',...
  [1,0]'+[0,-1]'*(4/3)*tan(pi/8),...
  [0,-1]'+[1,0]'*(4/3)*tan(pi/8),...
  [0,-1]'
  ],...
  LineToBezier([0,-1]',[-1,-1]'),...
  LineToBezier([-1,-1]',[-1,1]')...
  };


%%
% self-intersecting shcape
xx = 1;
yy = 3;
[c1, c2] = HalfBezierSingle([1,0; 1+1+xx, -yy; -1-1-xx, -yy; -1,0]');
CtrlPtsArray = {c2,[...
  -1,0; 1+2*xx, 2*yy; -1-2*xx, 2*yy; 1, 0 ...
  ]',...
  c1};

if false
  CtrlPtsArray = FlipBezierAll(CtrlPtsArray);
end

% self-intersecting circle
CtrlPtsArray = {[...
  [0,-1]',...
  [0,-1]'+[-1,0]'*(4/3)*tan(pi/8),...
  [-1,0]'+[0,-1]'*(4/3)*tan(pi/8),...
  [-1,0]'...
  ],[...
  [-1,0]',...
  [-1,0]'+[0,1]'*(4/3)*tan(pi/8),...
  [1,2]'+[0,-1]'*(4/3)*tan(pi/8),...
  [1,2]'
  ],[...
  [1,2]',...
  [1,2]'+[0,1]'*(4/3)*tan(pi/8),...
  [0,3]'+[1,0]'*(4/3)*tan(pi/8),...
  [0,3]'
  ],[...
  [0,3]',...
  [0,3]'+[-1,0]'*(4/3)*tan(pi/8),...
  [-1,2]'+[0,1]'*(4/3)*tan(pi/8),...
  [-1,2]'...
  ],[...
  [-1,2]',...
  [-1,2]'+[0,-1]'*(4/3)*tan(pi/8),...
  [1,0]'+[0,1]'*(4/3)*tan(pi/8),...
  [1,0]'...
  ],[...
  [1,0]',...
  [1, 0]'+[0,-1]'*(4/3)*tan(pi/8),...
  [0,-1]'+[1, 0]'*(4/3)*tan(pi/8),...
  [0,-1]'
  ]};
CtrlPtsArray = FlipBezierAll(CtrlPtsArray);

% up V with circle borders
R = [cos(pi/4), -sin(pi/4); sin(pi/4), cos(pi/4)];
CtrlPtsArray = {...
  R*LineToBezier([0,1]', [1,1]'), ...
  R*LineToBezier([1,1]', [1,-1]'), ...
  R*[...
  [1,-1]',...
  [1,-1]'+[0,-1]'*(2/3)*tan(pi/4),...
  [0,-1]'+[0,-1]'*(2/3)*tan(pi/4),...
  [0,-1]'
  ],...
  R*LineToBezier([0,-1]', [0,0]'), ...
  R*LineToBezier([0,0]', [-1,0]'), ...
  R*[...
  [-1,0]',...
  [-1,0]'+[-1,0]'*(2/3)*tan(pi/4),...
  [-1,1]'+[-1,0]'*(2/3)*tan(pi/4),...
  [-1,1]'
  ],...
  R*LineToBezier([-1,1]', [0,1]'), ...
  };

%%
%star with 5 spikes
aang   = -(0:(2*pi/5):(2*pi));
aang(end) = [];
PtsOut = [cos(aang + pi/2); sin(aang + pi/2)]*2;
PtsInn = [cos(aang + pi/2 - pi/5); sin(aang + pi/2 - pi/5)];

PtsAll = zeros(2,2*size(PtsInn,2)+1);
for i = 1:size(PtsInn,2)
  PtsAll(:,2*i-1) = PtsOut(:,i);
  PtsAll(:,2*i  ) = PtsInn(:,i);
end
PtsAll(:,end) = PtsOut(:,1);

CtrlPtsArray = {};
for i = 1:(size(PtsAll,2)-1)
  CurrCurve = zeros(2,4);
  CurrCurve(:,1) = PtsAll(:,i);
  CurrCurve(:,2) = (2/3)*PtsAll(:,i)+(1/3)*PtsAll(:,i+1);
  CurrCurve(:,3) = (1/3)*PtsAll(:,i)+(2/3)*PtsAll(:,i+1);
  CurrCurve(:,4) = PtsAll(:,i+1);
  %
  CtrlPtsArray{end+1} = CurrCurve;
end

CtrlPtsArray_backup = CtrlPtsArray;
[mid1, mid2] = HalfBezierSingle( CtrlPtsArray{1} );
CtrlPtsArray = { mid1, mid2 };
for i = 2:size(CtrlPtsArray_backup,2)
  CtrlPtsArray{end+1} = CtrlPtsArray_backup{i};
end

%%
% blobby star with 8 spikes
% unit circle
CtrlPtsArray = {[...
  [-1,0]',...
  [-1,(4/3)*tan(pi/8)]',...
  [-(4/3)*tan(pi/8),1]',...
  [0,1]'...
  ],[...
  [0,1]',...
  [1-(4/3)*tan(pi/8),1]',...
  [1,(4/3)*tan(pi/8)]',...
  [1,0]'...
  ],[...
  [1,0]',...
  [1,-(4/3)*tan(pi/8)]',...
  [(4/3)*tan(pi/8),-1]',...
  [0,-1]'...
  ],[
  [0,-1]',...
  [-(4/3)*tan(pi/8),-1]',...
  [-1,-(4/3)*tan(pi/8)]',...
  [-1,0]'
  ]};

% subdivide
CtrlPtsArray_backup = CtrlPtsArray;
CtrlPtsArray = {};
for i = 1:size(CtrlPtsArray_backup,2)
  [c1, c2] = HalfBezierSingle(CtrlPtsArray_backup{i});
  CtrlPtsArray{end+1} = c1;
  CtrlPtsArray{end+1} = c2;
end
CtrlPtsArray_backup = CtrlPtsArray;
CtrlPtsArray = {};
for i = 1:size(CtrlPtsArray_backup,2)
  [c1, c2] = HalfBezierSingle(CtrlPtsArray_backup{i});
  CtrlPtsArray{end+1} = c1;
  CtrlPtsArray{end+1} = c2;
end
%CtrlPtsArray = CtrlPtsArray_backup;

% make the wobly thingy
for i = 1:(size(CtrlPtsArray,2)/2)
  CurrCurve = CtrlPtsArray{2*i-1};
  CurrDisplace = (1-5/6)*CurrCurve(:,1);
  CurrCurve(:,[1,2]) = CurrCurve(:,[1,2]) - CurrDisplace;
  CurrDisplace = (7/6-1)*CurrCurve(:,4);
  CurrCurve(:,[3,4]) = CurrCurve(:,[3,4]) + CurrDisplace;
  CtrlPtsArray{2*i-1} = CurrCurve;
  %
  %
  CurrCurve = CtrlPtsArray{2*i};
  CurrDisplace = (7/6-1)*CurrCurve(:,1);
  CurrCurve(:,[1,2]) = CurrCurve(:,[1,2]) + CurrDisplace;
  CurrDisplace = (1-5/6)*CurrCurve(:,4);
  CurrCurve(:,[3,4]) = CurrCurve(:,[3,4]) - CurrDisplace;
  CtrlPtsArray{2*i} = CurrCurve;
end

%%
figure()
hold on
axis equal
grid on
for i = 1:size(CtrlPtsArray,2)
scatter(CtrlPtsArray{i}(1,:), CtrlPtsArray{i}(2,:))
end

BezOG  = AllBezierEval(CtrlPtsArray, 0.001);
figure()
hold on
axis equal
grid on
fill(BezOG(1,:),BezOG(2,:), 'r', 'EdgeColor', 'none');