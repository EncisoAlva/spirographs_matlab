% Corner case: the wheel can't continue rolling on the current curve
% because it will collide with the next curve.
% Search all corners from the shape generated by the Bezier curves, then
% removes them.
%
% ---- INUPUT ------------------------------------------------------------
%       Curve1/2  Array with control points for each one of the Bezier
%                 curves that make the curve {?} <- [2,4]'s
%            Tol  Max distance between points of the discretization [1]
%
% ---- OUTPUT ------------------------------------------------------------
% Curve1/2_short  Array with control points for each one of the Bezier
%                 curves AFTER replacing the corner portion {?} <- [2,4]'s
%           Time  Timestamps [1x?]
%       WhCtrPos  Location of the wheel center at timestamps [2x?]
%      MarkerPos  Location of marker at timepoints [2x?]
%
% The last control point of the last curve must be equal to the first
% control point of the first curve. This is not checked.
%
function [BPath_scaled] = RescalePath( BPath, MaxRangeX, MaxRangeY)

nCurves = size(BPath,2);

% init
minX = Inf;
maxX = -Inf;
minY = Inf;
maxY = -Inf;

% rudimentary bounding box, designed to be fast
% doesn't account for the actual curve, only control points
for i = 1:nCurves
  currCurve = BPath{i};
  % ony first and last control points are part of the curve
  minX = min( [minX, currCurve(1,1), currCurve(1,4)] );
  maxX = max( [maxX, currCurve(1,1), currCurve(1,4)] );
  minY = min( [minY, currCurve(2,1), currCurve(2,4)] );
  maxY = max( [maxY, currCurve(2,1), currCurve(2,4)] );
end
RangeX = maxX - minX;
RangeY = maxY - minY;

% the scale factor should guarantee that final size fits the limits
if RangeY * (MaxRangeX / RangeX) <= MaxRangeY
  scaleFactor = (MaxRangeX / RangeX);
elseif RangeX * (MaxRangeY / RangeY) <= MaxRangeX
  scaleFactor = (MaxRangeY / RangeY);
end

% scaling per se
BPath_scaled = cell(1, nCurves);
for i = 1:nCurves
  BPath_scaled{i} = BPath{i} * scaleFactor;
end

end