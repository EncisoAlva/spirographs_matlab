% Corner case: the wheel can't continue rolling on the current curve
% because it will collide with the next curve.
% Search all corners from the shape generated by the Bezier curves, then
% removes them.
%
% ---- INUPUT ------------------------------------------------------------
%       Curve1/2  Array with control points for each one of the Bezier
%                 curves that make the curve {?} <- [2,4]'s
%            Tol  Max distance between points of the discretization [1]
%
% ---- OUTPUT ------------------------------------------------------------
% Curve1/2_short  Array with control points for each one of the Bezier
%                 curves AFTER replacing the corner portion {?} <- [2,4]'s
%           Time  Timestamps [1x?]
%       WhCtrPos  Location of the wheel center at timestamps [2x?]
%      MarkerPos  Location of marker at timepoints [2x?]
%
% The last control point of the last curve must be equal to the first
% control point of the first curve. This is not checked.
%
function [BPath_rounded] = RemoveAllCorners( BPath, WheelRadius, Tol, ...
  SkipNegPi)

nCurves = size(BPath,2);
CornerAngles = zeros(1,nCurves);

% an array that will be changed multiple times
BPath_aux = BPath;
BPath_gap = BPath_aux;
for i = 1:nCurves
  BPath_gap{i} = [];
end

% check for corners
for i = 1:nCurves
  % next curve may be the first curve
  if i < nCurves
    i_ = i+1;
  else
    i_ = 1;
  end
  %
  % find the cornering angle
  TangentPre = EvalBezierNormal(BPath_aux{i},  1, WheelRadius );
  TangentPos = EvalBezierNormal(BPath_aux{i_}, 0, WheelRadius );
  if (norm(TangentPos)>Tol) && (norm(TangentPre)>Tol)
    CornerAngles(i) = mod( atan2(TangentPre(2),TangentPre(1)) - atan2(TangentPos(2),TangentPos(1)), 2*pi);
  else
    % exception: vanishing first derivative; throw to exception handler
    CornerAngles(i) = pi;
  end
  %
  % only act if wheel can't roll freely
  % worst-case scenario found: if the corner angle is -pi
  if CornerAngles(i) >= pi
    if (CornerAngles(i) == pi)&&(SkipNegPi)
      CornerAngles(i) = 0;
      continue
    end
    CurvePre = BPath_aux{i};
    CurvePos = BPath_aux{i_};
    [CurvePre_new, CurvePos_new, Curve_gap] =...
      RemoveSingleCorner(CurvePre, CurvePos, WheelRadius, Tol);
    %
    BPath_aux{i}  = CurvePre_new;
    BPath_aux{i_} = CurvePos_new;
    BPath_gap{i}  = Curve_gap;
  end
end

% get auxiliary curves in line
BPath_rounded = {};
for i = 1:nCurves
  BPath_rounded{end+1} = BPath_aux{i};
  if CornerAngles(i) >= pi
    BPath_rounded{end+1} = BPath_gap{i};
  end
end

% remove curves with all 4 points equal to each other
BPath_rounded = RemovePointCurves( BPath_rounded, Tol );

end