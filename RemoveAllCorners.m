% Corner case: the wheel can't continue rolling on the current curve
% because it will collide with the next curve.
% Search all corners from the shape generated by the Bezier curves, then
% removes them.
%
% ---- INUPUT ------------------------------------------------------------
%       Curve1/2  Array with control points for each one of the Bezier
%                 curves that make the curve {?} <- [2,4]'s
%            Tol  Max distance between points of the discretization [1]
%
% ---- OUTPUT ------------------------------------------------------------
% Curve1/2_short  Array with control points for each one of the Bezier
%                 curves AFTER replacing the corner portion {?} <- [2,4]'s
%           Time  Timestamps [1x?]
%       WhCtrPos  Location of the wheel center at timestamps [2x?]
%      MarkerPos  Location of marker at timepoints [2x?]
%
% The last control point of the last curve must be equal to the first
% control point of the first curve. This is not checked.
%
function [CtrlPtsArray_rounded] = RemoveAllCorners( CtrlPtsArray, WheelRadius, Tol, ...
  SkipNegPi)

nCurves = size(CtrlPtsArray,2);
CornerAngles = zeros(1,nCurves);

% an array that will be changed multiple times
CtrlPtsArray_aux = CtrlPtsArray;
CtrlPtsArray_gap = CtrlPtsArray_aux;
for i = 1:nCurves
  CtrlPtsArray_gap{i} = [];
end

% check for corners
for i = 1:nCurves
  % next curve may be the first curve
  if i < nCurves
    i_ = i+1;
  else
    i_ = 1;
  end
  %
  % find the cornering angle
  TangentPre = EvalBezierNormal(CtrlPtsArray_aux{i},  1, WheelRadius );
  TangentPos = EvalBezierNormal(CtrlPtsArray_aux{i_}, 0, WheelRadius );
  CornerAngles(i) = mod( atan2(TangentPre(2),TangentPre(1)) - atan2(TangentPos(2),TangentPos(1)), 2*pi);
  %
  % only act if wheel can't roll freely
  % worst-case scenario found: if the corner angle is -pi
  if CornerAngles(i) >= pi
    if (CornerAngles(i) == pi)&&(SkipNegPi)
      CornerAngles(i) = 0;
      continue
    end
    CurvePre = CtrlPtsArray_aux{i};
    CurvePos = CtrlPtsArray_aux{i_};
    [CurvePre_new, CurvePos_new, Curve_gap] =...
      RemoveCorner(CurvePre, CurvePos, WheelRadius, Tol);
    %
    CtrlPtsArray_aux{i}  = CurvePre_new;
    CtrlPtsArray_aux{i_} = CurvePos_new;
    CtrlPtsArray_gap{i}  = Curve_gap;
  end
end

% get auxiliary curves in line
CtrlPtsArray_rounded = {};
for i = 1:nCurves
  CtrlPtsArray_rounded{end+1} = CtrlPtsArray_aux{i};
  if CornerAngles(i) >= pi
    CtrlPtsArray_rounded{end+1} = CtrlPtsArray_gap{i};
  end
end

% remove curves with all 4 points equal to each other
CtrlPtsArray_rounded = RemovePointCurves( CtrlPtsArray_rounded, Tol );

end